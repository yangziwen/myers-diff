var MyersDiff=Object.assign(function(t){this.srcLines=t.srcLines,this.dstLines=t.dstLines,this.mapping={},this.prevStepMapping={};let e=parseInt(t.maxSearchDepth);this.maxSearchDepth=isNaN(e)?1e3:e,this.findAllSteps=!!t.findAllSteps,this.finalSteps=[],this.foundBestSteps=!1,this.bestFinalStep=null}.prototype,{NOT_EXIST_POSITION:{x:-1,y:-1},getPosition(d,k){with(this)return mapping[d]&&mapping[d][k]||NOT_EXIST_POSITION},getPrevStep(d,k){with(this)return prevStepMapping[d]&&prevStepMapping[d][k]||null},ensureSubmapping:(t,e)=>t[e]||(t[e]={}),addPosition(t,e,s){if(s==this.NOT_EXIST_POSITION)return!1;const i=this.getPosition(t,e);return s.x>i.x&&(this.ensureSubmapping(this.mapping,t)[e]=s,!0)},getBestFinalStep(){return this.bestFinalStep},getFinalSteps(){return this.finalSteps},getBestSteps(){return this.getSteps(this.bestFinalStep)},getBestPositions(){return this.getPositions(this.bestFinalStep)},getPositions(t){return this.getSteps(t).map((t=>this.getPosition(t.d,t.k)))},getSteps(t){if(!t)return[];let e=[t],{d:s,k:i}=t,n=this.getPrevStep(s,i);for(;n;)e.unshift(n),s=n.d,i=n.k,n=this.getPrevStep(s,i);return e},getEdits(t){if(t||(t=this.getBestFinalStep()),!t)return[];let e={x:0,y:0},s=[{type:"common",lines:[],fromOffset:0,toOffset:0}],i=s[0];for(let n of this.getPositions(t)){let{x:t,y:h}=e,l=n.x-e.x,p=n.y-e.y,r=Math.min(l,p),f="common";l>p?f="delete":l<p&&(f="add"),f!=i.type&&(i={type:f,lines:[],fromOffset:t,toOffset:h},s.push(i)),"delete"==f?(i.lines.push(this.srcLines[e.x]),t++):"add"==f&&(i.lines.push(this.dstLines[e.y]),h++),r>0&&("common"!=i.type&&(i={type:"common",lines:[],fromOffset:t,toOffset:h},s.push(i)),i.lines.push(...this.srcLines.slice(t,t+r))),e=n}return 0==s[0].lines.length&&s.shift(),s},getDiffBlocks(t,e){let s=this.getEdits(t);if(!s||0==s.length)return[];if(!s.find((t=>"common"!=t.type)))return[];isNaN(e=parseInt(e))&&(e=3);let i={edits:[]};(e>0||["delete","add"].includes(s[0].type))&&i.edits.push(s[0]);let n=[i],h=s.slice(-1)[0];for(let t=1;t<s.length;t++){let l=s[t];["delete","add"].includes(l.type)?i.edits.push(l):"common"==l.type&&(e>0&&i.edits.push(l),l.lines.length>2*e&&l!==h&&(i={edits:[]},e>0&&i.edits.push(l),n.push(i)))}for(let t of n){let s=t.edits,i=s[0],n=s.slice(-1)[0],h=s.slice(1,-1),l=[],p=[];if("common"==i.type&&i.lines.length>e?(t.fromOffset=i.fromOffset+i.lines.length-e,t.toOffset=i.toOffset+i.lines.length-e,l.push(...i.lines.slice(-e))):(t.fromOffset=i.fromOffset,t.toOffset=i.toOffset,l.push(...i.lines)),"common"==n.type&&n.lines.length>e)t.fromLineCount=n.fromOffset-t.fromOffset+e,t.toLineCount=n.toOffset-t.toOffset+e,p.push(...n.lines.slice(0,e));else{let e="add"!=n.type?n.lines.length:0,s="delete"!=n.type?n.lines.length:0;t.fromLineCount=n.fromOffset-t.fromOffset+e,t.toLineCount=n.toOffset-t.toOffset+s,p.push(...n.lines)}let r=t.fromOffset+(t.fromLineCount>0?1:0),f=t.toOffset+(t.toLineCount>0?1:0),o=[`@@ -${r},${t.fromLineCount} +${f},${t.toLineCount} @@`],u=t=>{switch(t){case"delete":return"-";case"add":return"+";default:return" "}};o.push(...l.map((t=>u(i.type)+t)));for(let t of h)o.push(...t.lines.map((e=>u(t.type)+e)));i!==n&&o.push(...p.map((t=>u(n.type)+t))),t.lines=o}return n},getStandardDiff(t,e){return this.getDiffBlocks(t,e).map((t=>t.lines)).flatMap((t=>t))},getSimpleDiff(t){let e=this.getEdits(t),s=[];for(let t of e)"common"==t.type?s.push(...t.lines.map((t=>"  "+t))):"delete"==t.type?s.push(...t.lines.map((t=>"- "+t))):"add"==t.type&&s.push(...t.lines.map((t=>"+ "+t)));return s},calDiff(){let t=Math.min(this.maxSearchDepth,this.srcLines.length+this.dstLines.length);for(let e=0;e<=t&&(!this.foundBestSteps||this.findAllSteps);e++)this.calAndAddPositions(e);return this},calShortcutLines(){var t={};for(let e=0;e<this.srcLines.length;e++){let s=this.srcLines[e];(t[s]||(t[s]=[])).push(e)}let e={};for(let s=0;s<this.dstLines.length;s++){let i=this.dstLines[s];if(t[i]){let n=t[i].map((t=>[t,s]));for(let t of n){let s=t.join(","),i=t.map((t=>t-1)).join(","),n=t.map((t=>t+1)).join(",");e[s]||(e[i]?e[i].push(t):e[n]?((e[s]=e[n]).unshift(t),delete e[n]):e[s]=[t])}}}return Object.values(e).map((t=>(t.push(t.slice(-1)[0].map((t=>t+1))),t)))},calAndAddPositions(t){for(let e=t;e>=-t;e-=2){let s=this.calPosition(t,e);if(this.addPosition(t,e,s)&&(this.ensureSubmapping(this.prevStepMapping,t)[e]=s.prevStep),this.foundBestSteps&&!this.findAllSteps)return}},calPosition(t,e){if(t<=0){let t=0,e=0;for(;t<this.srcLines.length&&e<this.dstLines.length&&this.srcLines[t]==this.dstLines[e];)t++,e++;return{x:t,y:e}}let s=t-1,i=[e-1,e+1].map((i=>{if(i<-s||i>s)return this.NOT_EXIST_POSITION;let n=this.getPosition(s,i);if(n==this.NOT_EXIST_POSITION)return this.NOT_EXIST_POSITION;let{x:h,y:l}=n;if(e>i&&h++,e<i&&l++,h>this.srcLines.length||l>this.dstLines.length)return this.NOT_EXIST_POSITION;for(;h<this.srcLines.length&&l<this.dstLines.length&&this.srcLines[h]==this.dstLines[l];)h++,l++;return h==this.srcLines.length&&l==this.dstLines.length&&(this.finalSteps.push({d:t,k:e}),this.foundBestSteps||(this.foundBestSteps=!0,this.bestFinalStep={d:t,k:e})),{x:h,y:l,prevStep:{d:s,k:i}}}));return i[0].x>i[1].x?i[0]:i[1]}}).constructor;